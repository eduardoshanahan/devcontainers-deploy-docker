#!/bin/bash

# Enhanced error handler for unattended upgrades
# This script runs daily to check and fix common issues

LOG_FILE="/var/log/unattended-upgrade-error-handler.log"
ERROR_STATE_FILE="/var/log/unattended-upgrade-errors.state"
EMAIL="{{ configure_security_updates_email }}"

log() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" >> "$LOG_FILE"
}

# Function to check if error has already been reported
is_error_already_reported() {
    local error_hash="$1"
    if [ -f "$ERROR_STATE_FILE" ] && grep -q "$error_hash" "$ERROR_STATE_FILE"; then
        return 0  # Already reported
    fi
    return 1  # Not reported yet
}

# Function to mark error as reported
mark_error_as_reported() {
    local error_hash="$1"
    local error_timestamp="$2"
    echo "$error_hash|$error_timestamp" >> "$ERROR_STATE_FILE"
}

# Enhanced function to check if error is recent enough to report
is_error_recent() {
    local error_timestamp="$1"
    local current_time=$(date +%s)
    local error_time=$(date -d "$error_timestamp" +%s 2>/dev/null || echo "0")
    local time_diff=$((current_time - error_time))
    
    # Only report errors from the last 7 days (604800 seconds)
    if [ $time_diff -lt 604800 ]; then
        return 0  # Recent enough to report
    fi
    return 1  # Too old to report
}

# Function to clean old error entries from state file
cleanup_old_errors() {
    if [ -f "$ERROR_STATE_FILE" ]; then
        local temp_file=$(mktemp)
        local current_time=$(date +%s)
        
        while IFS='|' read -r hash timestamp; do
            if [ -n "$hash" ] && [ -n "$timestamp" ]; then
                local error_time=$(date -d "$timestamp" +%s 2>/dev/null || echo "0")
                local time_diff=$((current_time - error_time))
                
                # Keep errors from the last 30 days (2592000 seconds)
                if [ $time_diff -lt 2592000 ]; then
                    echo "$hash|$timestamp" >> "$temp_file"
                fi
            fi
        done < "$ERROR_STATE_FILE"
        
        mv "$temp_file" "$ERROR_STATE_FILE"
        log "Cleaned up old error entries from state file"
    fi
}

notify_error() {
    local message="$1"
    log "ERROR: $message"
    
    if [ -n "$EMAIL" ]; then
        echo "$message" | mail -s "Unattended Upgrade Error Alert" "$EMAIL"
    fi
}

notify_success() {
    local message="$1"
    log "SUCCESS: $message"
}

# Clean up old error entries at the start
cleanup_old_errors

# Check if apt is locked
if fuser /var/lib/dpkg/lock >/dev/null 2>&1; then
    notify_error "APT is locked, waiting for lock to be released"
    sleep 300
fi

# AGGRESSIVE CACHE CLEARING - Clear all caches every time
log "Starting aggressive cache clearing and repository health check"

# Clear all apt caches
apt clean >> "$LOG_FILE" 2>&1
apt autoclean >> "$LOG_FILE" 2>&1
apt autoremove >> "$LOG_FILE" 2>&1

# Clear package lists cache
rm -rf /var/lib/apt/lists/* >> "$LOG_FILE" 2>&1 || true

# Clear dpkg cache
rm -rf /var/cache/apt/archives/*.deb >> "$LOG_FILE" 2>&1 || true

# Force update package lists with fresh cache
if apt update >> "$LOG_FILE" 2>&1; then
    notify_success "Package lists updated successfully after cache clearing"
else
    notify_error "Failed to update package lists after cache clearing"
    # Try to fix repository issues
    apt autoclean >> "$LOG_FILE" 2>&1
    apt autoremove >> "$LOG_FILE" 2>&1
fi

# Check for and fix broken packages
if dpkg --configure -a >> "$LOG_FILE" 2>&1; then
    notify_success "Fixed any broken package configurations"
else
    notify_error "Failed to fix broken package configurations"
fi

# Enhanced handling for problematic kernel packages
PROBLEMATIC_PACKAGES=("linux-virtual" "linux-image-virtual" "linux-image-generic")

for package in "${PROBLEMATIC_PACKAGES[@]}"; do
    if dpkg -l | grep -q "^ii.*$package"; then
        log "Found potentially problematic package: $package"
        
        # Check if there's a newer version available
        if apt list --upgradable 2>/dev/null | grep -q "$package"; then
            log "Attempting to upgrade $package with enhanced error handling"
            
            # First, try to remove any held packages
            echo "$package install" | dpkg --set-selections
            
            # Try to upgrade with specific error handling and force options
            if apt install --only-upgrade "$package" -o Dpkg::Options::="--force-confdef" -o Dpkg::Options::="--force-confold" -o Dpkg::Options::="--force-depends" >> "$LOG_FILE" 2>&1; then
                notify_success "Successfully upgraded $package"
            else
                notify_error "Failed to upgrade $package, attempting alternative approach"
                
                # Try to install the latest available version
                if apt install "$package" -o Dpkg::Options::="--force-confdef" -o Dpkg::Options::="--force-confold" >> "$LOG_FILE" 2>&1; then
                    notify_success "Successfully installed latest version of $package"
                else
                    notify_error "Failed to install $package, marking as held and skipping"
                    echo "$package hold" | dpkg --set-selections
                fi
            fi
        fi
    fi
done

# Enhanced 404 error detection with better deduplication
if [ -f "/var/log/unattended-upgrades/unattended-upgrades.log" ]; then
    log "Checking for 404 errors in unattended upgrades log"
    
    # Extract 404 errors with timestamps from the last 7 days
    local seven_days_ago=$(date -d '7 days ago' '+%Y-%m-%d')
    
    # Use awk to extract errors with timestamps and create unique identifiers
    awk -v cutoff="$seven_days_ago" '
        $0 >= cutoff && /404|not found/i {
            # Extract timestamp and create a more specific error identifier
            timestamp = $1 " " $2
            # Create a hash that includes package name and error type for better deduplication
            if (match($0, /linux-virtual|linux-image/)) {
                error_type = "kernel_404"
            } else if (match($0, /404/)) {
                error_type = "general_404"
            } else {
                error_type = "not_found"
            }
            
            # Create a unique identifier: timestamp + error_type + first few words
            identifier = timestamp "|" error_type "|" substr($0, 1, 50)
            print identifier
        }
    ' "/var/log/unattended-upgrades/unattended-upgrades.log" | while IFS='|' read -r timestamp error_type error_summary; do
        
        if [ -n "$timestamp" ] && [ -n "$error_type" ]; then
            # Generate hash for this specific error
            ERROR_HASH=$(echo "${timestamp}|${error_type}|${error_summary}" | md5sum | cut -d' ' -f1)
            
            log "Found error: Type=$error_type, Summary=${error_summary:0:50}..."
            
            # Only notify if this error hasn't been reported before AND is recent
            if ! is_error_already_reported "$ERROR_HASH" && is_error_recent "$timestamp"; then
                notify_error "New unattended-upgrade error detected: $error_type - ${error_summary:0:100}..."
                mark_error_as_reported "$ERROR_HASH" "$timestamp"
                log "Marked new error as reported with hash: $ERROR_HASH"
            else
                if is_error_already_reported "$ERROR_HASH"; then
                    log "Error already reported, skipping: $ERROR_HASH"
                else
                    log "Error too old to report: $timestamp"
                fi
            fi
            
            # Attempt fixes for kernel package errors (regardless of reporting status)
            if [ "$error_type" = "kernel_404" ]; then
                log "Attempting to fix kernel package 404 error"
                
                # Force update of package lists with cache clearing
                apt clean >> "$LOG_FILE" 2>&1
                apt update --fix-missing >> "$LOG_FILE" 2>&1
                
                # Try to install the latest available kernel packages
                apt install --only-upgrade linux-virtual linux-image-virtual linux-image-generic -o Dpkg::Options::="--force-confdef" -o Dpkg::Options::="--force-confold" >> "$LOG_FILE" 2>&1 || true
            fi
        fi
    done
fi

# Check for any held packages and try to resolve them
HELD_PACKAGES=$(dpkg --get-selections | grep hold | awk '{print $1}')
if [ -n "$HELD_PACKAGES" ]; then
    log "Found held packages: $HELD_PACKAGES"
    
    for package in $HELD_PACKAGES; do
        if [[ "$package" =~ linux- ]]; then
            log "Attempting to resolve held kernel package: $package"
            
            # Try to install the latest version
            echo "$package install" | dpkg --set-selections
            apt install "$package" -o Dpkg::Options::="--force-confdef" -o Dpkg::Options::="--force-confold" >> "$LOG_FILE" 2>&1 || true
        fi
    done
fi

# Final aggressive cleanup and repository refresh
apt clean >> "$LOG_FILE" 2>&1
apt autoclean >> "$LOG_FILE" 2>&1
apt autoremove >> "$LOG_FILE" 2>&1

# Force update of package lists to ensure we have the latest repository information
apt update --fix-missing >> "$LOG_FILE" 2>&1

log "Enhanced repository health check with aggressive cache clearing completed"

# Rotate log file if it gets too large
if [ -f "$LOG_FILE" ] && [ $(stat -c%s "$LOG_FILE") -gt 1048576 ]; then
    mv "$LOG_FILE" "${LOG_FILE}.1"
    gzip "${LOG_FILE}.1" 2>/dev/null || true
fi

# Rotate error state file if it gets too large (prevent it from growing indefinitely)
if [ -f "$ERROR_STATE_FILE" ] && [ $(stat -c%s "$ERROR_STATE_FILE") -gt 1048576 ]; then
    mv "$ERROR_STATE_FILE" "${ERROR_STATE_FILE}.1"
    gzip "${ERROR_STATE_FILE}.1" 2>/dev/null || true
fi 